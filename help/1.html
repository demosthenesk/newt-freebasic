<html><body> 
	<h1>Help documentation of newt-freebasic</h1>
	
	<table border="0" width="100%">
	<tbody>
    <tr>
      <td align="left"><a href="index.html">Prev</a></td>
      <td align="center"><a href="index.html">Home</a></td>
      <td align="right"><a href="2.html">Next</a></td></tr>
	</tbody>
</table>
<hr/>	
<p><b>Table of Contents</b></p>
	<ol><li><a href="1.html#1">Introduction</a> <ol><li><a href="1.html#1-1">Background</a></li><li><a href="1.html#1-2">Designing newt applications</a></li><li><a href="1.html#1-3">Components</a></li><li><a href="1.html#1-4">Conventions</a>&nbsp;&nbsp;</li>
				</ol></li>
		</ol>
	<h2><a name="1">1. Introduction</a></h2>
	<p>Newt has a definite design philosophy behind it, and knowing that design makes it significantly easier to craft robust newt applications. This tutorial documents newt 0.30 and it is an extension to Erik's Troan tutorial --- older versions of newt had annoying inconsistencies in it, which were removed while Erik's tutorial was written. The latest version of newt is always available from Red Hat at <a href="https://pagure.io/newt/releases">https://pagure.io/newt/releases</a> or <a href="https://github.com/mlichvar/newt">https://github.com/mlichvar/newt</a> The latest newt-freebasic files are always available from GitHub at <a href="https://github.com/demosthenesk/newt-freebasic">https://github.com/demosthenesk/newt-freebasic</a>&nbsp;</p>
	<p><b>libnewt.a</b> and <b>libnewt.so</b> are the libraries and <b>newt.bi</b> is the header file for freebasic projects.</p>
	<p>You can copy <b>libnewt.a</b> and <b>libnewt.so</b> and <b>newt.bi</b> to the folder of your bas file or install <b>libnewt-dev.deb</b> for your Debian/Ubuntu operating system or <b>libnewt-dev.rpm </b> for your Red Hat operating system.</p>
	<p>Special thanks to <b>Angelo Rosina</b> aka <b>angros47</b> who translated three c examples to freebasic (testtree.bas, testgrid.bas, test.bas)</p><p>Special thanks also to <b>SARG</b> who helped me at the begining of translating newt.h with fbfrog app and for trying to build libnewt.a for windows.</p><p>This version of <b>libnewt.a</b> and <b>libnewt.so</b> works only for linux 64 bit.</p><p>Together with <b>SARG</b> tried to make it work for windows but we have no success.</p>
	<h2><a name="1-1">1.1 Background</a></h2>
	<p><tt>Newt</tt>&nbsp;was originally designed for use in the install code for Red Hat Linux. As this install code runs in an environment with limited resources (most importantly limited filesystem space),&nbsp;<tt>newt</tt>'s size was immediately an issue. To help minimize its size, the following design decisions were made early in its implementation:</p><ul><li> <p><tt>newt</tt>&nbsp;does not use an event-driven architecture.</p></li><li> <p><tt>newt</tt>&nbsp;is written in C, not C++ and <b>newt.bi</b> was produced automatically in freebasic with the help of <a href="https://github.com/dkl/fbfrog">fbfrog</a>&nbsp;program from <b>newt.h</b>.</p></li><li> <p>Windows must be created and destroyed as a stack (in other words, all&nbsp;<tt>newt</tt>&nbsp;windows behave as modal dialogs). This is probably the greatest functionality restriction of&nbsp;<tt>newt</tt>.</p></li><li> <p>The tty keyboard is the only supported input device.</p></li><li> <p>Many behaviours, such as widget traversal order, are difficult or impossible to change.</p></li></ul><p>While&nbsp;<tt>newt</tt>&nbsp;provides a complete API, it does not handle the low-level screen drawing itself. Instead,&nbsp;<tt>newt</tt>&nbsp;is layered on top of the screen management capabilities of John E. Davis's&nbsp;<a href="ftp://space.mit.edu/pub/davis/slang/">S-Lang</a>&nbsp;library.</p>
	<h2><a name="1-2">1.2&nbsp;Designing newt applications</a><!--EndFragment--></h2>
	<p>As&nbsp;<tt>newt</tt>&nbsp;is not event driven and forces modal windows (forcing window order to behave like a stack), newt applications tend to look quite like other text-mode programs. It is quite straightforward to convert a command line program which uses simple user prompts into a&nbsp;<tt>newt</tt>&nbsp;application. Some of the programs run as part of the Red Hat installation process (such as&nbsp;<tt>Xconfigurator</tt>&nbsp;and&nbsp;<tt>mouseconfig</tt>) were originally written as simple terminal mode programs which used line-oriented menus to get input from the user and were later converted into&nbsp;<tt>newt</tt>&nbsp;applications (through a process affectionately known as newtering). Such a conversion does not require changes to the control flow of most applications. Programming&nbsp;<tt>newt</tt>&nbsp;is dramatically different from writing programs for most other windowing systems as&nbsp;<tt>newt</tt>'s API is not event driven. This means that&nbsp;<tt>newt</tt>&nbsp;applications look dramatically different from programs written for event-driven architectures such as Motif,&nbsp;, or even Borland's old TurboVision libraries. When you're designing your&nbsp;&nbsp;program, keep this differentiation in mind. As long as you plan your application to call a function to get input and then continue (rather then having your program called when input is ready), programming with the newt libraries should be simple.&nbsp;program, keep this differentiation in mind. As long as you plan your application to call a function to get input and then continue (rather then having your program called when input is ready), programming with the newt libraries should be simple.</p>
	<h2><a name="1-3">1.3&nbsp;Components</a><!--EndFragment--></h2>
	<p>Displayable items in&nbsp;<tt>newt</tt>&nbsp;are known as&nbsp;<i>components</i>, which are analogous to the widgets provided by most Unix widget sets. There are two main types of components in&nbsp;<tt>newt</tt>, forms and everything else. Forms logically group components into functional sets. When an application is ready to get input from a user, it ``runs a form'', which makes the form active and lets the user enter information into the components the form contains. A form may contain any other component, including other forms. Using subforms in this manner lets the application change the details of how the user tabs between components on the form, scroll regions of the screen, and control background colors for portions of windows. Every component is of type&nbsp;<tt>newtComponent</tt>, which is an opaque type. It's guaranteed to be a pointer though, which lets applications move it through void pointers if the need arises. Variables of type&nbsp;<tt>newtComponent</tt>&nbsp;should never be directly manipulated -- they should only be passed to&nbsp;<tt>newt</tt>&nbsp;functions. As&nbsp;<tt>newtComponent</tt>&nbsp;variables are pointers, remember that they are always passed by value -- if you pass a&nbsp;<tt>newtComponent</tt>&nbsp;to a function which manipulates it, that component is manipulated everywhere, not just inside of that function (which is nearly always the behaviour you want).&nbsp;&nbsp;applications look dramatically different from programs written for event-driven architectures such as Motif,&nbsp;&nbsp;program, keep this differentiation in mind. As long as you plan your application to call a function to get input and then continue (rather then having your program called when input is ready), programming with the newt libraries should be simple.program, keep this differentiation in mind. As long as you plan your application to call a function to get input and then continue (rather then having your program called when input is ready), programming with the newt libraries should be simple.</p>
	<h2><a name="1-4">1.4&nbsp;Conventions</a><!--EndFragment--></h2>
	<p><tt>Newt</tt>&nbsp;uses a number of conventions to make it easier for programmers to use.</p><ul><li> <p>All functions which manipulate data structures take the data structure being modified as their first parameter. For example, all of the functions which manipulate forms expect the&nbsp;<tt>newtComponent</tt>&nbsp;for that form to be the first parameter.for that form to be the first parameter.</p></li><li> <p>As&nbsp;<tt>newt</tt>&nbsp;is loosely typed (forcing all of the components into a single variable makes coding easier, but nullifies the value of type checking),&nbsp;<tt>newt</tt>&nbsp;functions include the name of the type they are manipulating. An example of this is&nbsp;<tt>newtFormAddComponent()</tt>, which adds a component to a form. Note that the first parameter to this function is a form, as the name would suggest.&nbsp;&nbsp;&nbsp;</p></li><li> <p>When screen coordinates are passed into a function, the x location precedes the y location. To help keep this clear, we'll use the words ``left'' and ``top'' to describe those indicators (with left corresponding to the x position).</p></li><li> <p>When box sizes are passed, the horizontal width precedes the vertical width.</p></li><li> <p>When both a screen location and a box size are being passed, the screen location precedes the box size.</p></li><li> <p>When any component other then a form is created, the first two parameters are always the (left, right) location.</p></li><li> <p>Many functions take a set of flags as the final parameter. These flags may be logically ORed together to pass more then one flag at a time.</p></li><li> <p><tt>Newt</tt>&nbsp;uses&nbsp;<i>callback</i>&nbsp;functions to convey certain events to the application. </p>
			<p>While callbacks differ slightly in their parameters, most of them allow the application to specify an arbitrary argument to be passed to the callback when the callback is invoked. This argument is always aa&nbsp;<tt>void *</tt> or an <tt>any ptr</tt> (in freebasic terms) which allows the application great flexibility.</p></li></ul>
	
	

	<hr/>
		<table border="0" width="100%">
	<tbody>
    <tr>
      <td align="left"><a href="index.html">Prev</a></td>
      <td align="center"><a href="index.html">Home</a></td>
      <td align="right"><a href="2.html">Next</a></td></tr>
	</tbody>
</table>
<p></p></body></html>